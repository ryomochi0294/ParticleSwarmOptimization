%Newtonian Approach to geolocation

import random
import time
import numpy as np
import matplotlib.pyplot as plt

Pt = 4  # Transmitter power in dbm
#Pt = (1000) * (10 ** (Pt / 10))
Pr = -69  # RSSI
#Pr = (1000) * (10 ** (Pr / 10))
x0 = 1  # x position of the observer
y0 = 2  # y position of the observer
alpha = 2.3  # constant coefficient for shadowing (Object in the way like walls, window, etc)
x = 13
y = 12
s = 0
gx = []
gy = []
hx = []
hy = []
a = np.array([[1],
               [2]])

d = ((x - x0) ** 2 + (y - y0) ** 2)
s1 = 0
s2 = 0
s4 = 0
g1 = 0
g2 = 0

def objective_function(x, y, Pr):
    global s1, s2, s4
    global g1, g2
    d = ((x - x0) ** 2 + (y - y0) ** 2)
    Hess1 = (4 * (s1 + Pr * alpha) * (Pr * (d ** (alpha - 1)) - Pt * (d ** ((alpha / 2) - 1)))) + 2 * Pr * alpha * (
                (x0 - x) ** 2) * (Pr * (alpha - 1) * (d ** (alpha - 2)) - Pt * (d ** ((alpha / 2) - 2)))
    Hess23 = (4 * (s2 + Pr * alpha * (x0 - x) * (y0 - y) * (
            Pr * (alpha - 1) * (d ** (alpha - 2)) - Pt * ((alpha / 2) - 1) * (d ** ((alpha / 2) - 2)))))
    Hess4 = (4 * (s4 + Pr * alpha) * (Pr * (d ** (alpha - 1)) - Pt * (d ** ((alpha / 2) - 1)))) + 2 * Pr * alpha * (
                (y0 - y) ** 2) * (Pr * (alpha - 1) * (d ** (alpha - 2)) - Pt * (d ** ((alpha / 2) - 2)))
    grad1 = 2 * (g1 + Pr * alpha * (x0 - x) * (Pr * (d ** (alpha - 1)) - Pt * (d ** ((alpha / 2) - 1))))
    grad2 = 2 * (g2 + Pr * alpha * (y0 - y) * (Pr * (d ** (alpha - 1)) - Pt * (d ** ((alpha / 2) - 1))))
    Grad = [[grad1],
            [grad2]]
    s1 = Hess1 + s1
    s2 = Hess23 + s2
    s4 = Hess4 + s4
    g1 = grad1 + g1
    g2 = grad2 + g2
    #print(Hess1)
    #print(Hess23)
    #print(Hess4)
    Hess = np . array ([[ Hess1 , Hess23 ], [ Hess23 , Hess4 ]])
    print(Hess)
    Hessinv = np.linalg.inv(Hess)  # Hessian Inverse
    xn = [[x],
          [y]]
    res = np.array([[0 for xx in range(2)] for yy in range(1)])
    #Matrix Multiplication
    res = np.matmul(Hessinv, Grad)
    # z is the objective function it minimizes based on variables x and y
    # z =
    # print(z)
    return res
count = 0
a = objective_function(x, y, -69)
x = float(a[0])
y = float(a[1])
i = 1
while(count < 50):
    a = objective_function(x, y, -69+(count))
    x = float(a[0])
    y = float(a[1])
    print(a)
    count += 1
print(a)
